#python
##[转义字符](#转义字符)
##[变量](#变量)
##[数据转换](#数据转换)
##[运算符](#运算符)
##[函数](#函数)
##[命令](#命令)
##[列表](#列表)
##[字典](#字典)





# \#是注释


#转义字符
* 换行：__\n__  
* 制表符 ：__\t__  
* return（光标回到这一行的开头）：__\r__  
* backspace退一格：__\b__  
* \\\
* 原字符，不希望字符串中的转义字符起作用，就在前面使用r
eg: `print(r'hellow\nworld')`
注意，最后的一个字符不能是反斜杠，否则会报错


#变量  
+ 变量可以由三部分组成
+ 标识：表示对象所存储的内存地址，使用函数id()获取  
+ 类型：表示对象的数据结构，使用函数type()  
+ 值：表示对象所存储的具体数据，使用print()哦可以打印出来  
name = 'chen'  
name地址 -> ()

+ ## 数字类型包括：  
	+ int（长整型）  
	+ float（浮点型）  
	+ complex（复数）  

+ ## 布尔类型（Boolean）  
	+ 布尔类型是与逻辑相关一种数据类型，只有两个值：True(真)与False(假)  
	+ 其中布尔类型值可以相加，但一旦相加，类型就会转换为int类型  
+ ## 字符串类型（String）
	   在Python变量定义中，如果其赋值的内容是通过单引号或双引号引起来的内容就是字符串str类型。
	
	+ 字符串操作：
	+ 字符串索引  
	    a[i]代表字符串a第i+1个位置的索引，a[-1]代表字符串a最后一个位置的索引  
	+ 字符串截取    
	    s=a[i:j],其中i,j可以不写，表示从位置i开始到位置j结束，其中截取的字符串不包括位置j  
	+ 字符串拼接：“+”        
	+ 字符串复用：“*“  


+ ## [列表类型](#列表)（List）
	
	+ 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌+ + 套或者叫多维列表，可以用来表示多维数组）。
 	+ 数组操作与字符串类型类似  
	
	+ 多维数组初始化：   
	[…[[[0 for i in range(x)] for j in range(y)] for k in range(z)]…]  
	
+ ## 元组类型(Tuple)  
	
	+ python的元组类似于list列表，元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。  
	+ 它支持字符，数字，字符串，列表，元组等所有类型。  
	+ 元组的取值、截取、连接、重复与列表一样。
	+ tuple的元素不可改变，但它可以包含可变的对象(上述可变数据)，比如list列表。  
+ ## 集合类型（Set）

    + 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。
    + 基本功能是进行成员关系测试和删除重复元素。  
    + 可以使用大括号 { } 或者 set() 函数创建集合。 
    + 注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典不能往集合里边添加可变数据类型的数据   
+ ##[字典类型](#字典)（Dictionary）
	+ 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型；列表是有序的对象集合，字典是无序的对象集合；字典用"{ }"标识；字典由索引(key)和它对应的值value组成  
	+ 字典取值，字典当中的元素是通过键来存取的，而不是通过偏移存取
	+ 键(key)必须使用不可变类型（数字、布尔、字符串、元组）  
	+ 在同一个字典中，键(key)必须是唯一的  

#运算符
##[=](#=)  
##[+](#+)  
##[/](#/)  
##[//](#//)  
##[**](#**)  
##[%](#\%)  
##[**](#**)  
##[bool运算符](#bool运算符)  
##[位运算符](#位运算符)  
##[比较运算符](#比较运算符)  



##=
变量     赋值号  值  
name      =        50  

解包赋值
a,b,c = 29,30,48  
它允许这样对应赋值，也是从右到左  
所以：交换两个变量的值可以    b,a = a,b



##+  
对于 字符串起连接作用  
```python
s1 = hello
s2 = world
print(s1+s2)
```
输出--> helloworld     
对于其他的数就是正常的加
```python
A = [1, 2, 3]
B = [4, 5, 6]
print(A+B)
print(A)
```
输出
```
[1, 2, 3, 4, 5, 6]
[1, 2, 3]
```
+与extend()在效果上具有相同的功能，但是实际上生成了一个新的列表来存放这两个列表的和，只能用在两个列表相加上。


```python
A = [1, 2, 3]
B = [4, 5, 6]
A += B
print(A)
```
输出
```
[1, 2, 3, 4, 5, 6]
```

##/  
除法运算  
需要注意的是  
eg：11/2 = 5.5

  

##//  
整除运算  
11/2 = 5  


##%  
取余运算  
11%2 = 1  
正常的取余数  

如果是一正一负

eg: 9%-4 = -3  
+ 一.忘记求商结果是负数时要向下取整，比如-2.25等于-3。
+ 二.是把负数求余运算和正数求余运算混为一谈正数求余运算比如9%4=1，思路可以想成9里面有两个4，还剩一个1，所以余数为1；
负数求余运算则不然，9%-4=-3，你不能想成拿9去除-4等于-2余1，所以结果为1；
+ 三.算商时错误求商，9%-4的商为：9/-4=-2.25=-3(负数向下取整)。而不是：9/-4＝-2余1，所以商为2  
+ 求余运算,公式为：余数＝被除数-除数\*商，商＝被除数/除数(结果精确到小数，取整)





##**

次方运算  
2\*\*3 = 8    ---->(2^3)



##bool运算符
与C语言比
and   --->  &&  
or     --->   ||  
not   --->   !  

##in 
s = 'hello world'  
('w' in s) = True  
("k" in s) = False  
就是判断一个字符在一个字符串s中有没有存在  
则__not in__ 反之  
也可以用于判断一个序列中有没有该数
eg：
```python
    r = range(10)
    print(list(r))
    print(4 in r)
```
输出      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  
      True  

##is
判断两个变量的id是否相同（理解成地址）  



##位运算符  
+ & : 按位与        同为1为1，否则为0  
+ | : 按位或         有1为1，同为0才为0  
+ ~ : 按位取反     1变0，0变1  
+ \` : 按位异或    不同为1，相同为0  
+ << : 左移位       高位溢出，低位补零  相当×2  
+ \>> : 右移位	   符号位不变，左边补上符号位。
**按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1**。（算数移位）


##比较运算符  
+ <
+ >  
+ ==  
+ <=  
+ >=  
python 可以用连续比较  
eg：59 <x<89  

回到[运算符](#运算符)  




#数据转换  
* str()  可以用引号如下面的 '我叫'  
* int()  
	* 文字类和小数类字符串无法转换成整数  
	* 浮点数则是抹零取整    
* float()  
	* 文字类无法转换  
	* 整数转换成浮点，末尾为.0  
将括号内的数据转换成括号前的类型  

eg:   
```python
	name = '张三'  
	age = 20  
	print('我叫' + name + '今年' + str(age) + '岁')
```
输出---> 我叫张三今年20岁  

eg2:   
```python
	s1 = '128'    
	print(int(s1), type(s1))
```
输出---> 128 <class 'int'>

eg3: 
```python
	f1 = 89.9    
	print(int(f1), type(f1))
```
输出---> 89 <class 'int'>  

这里的加号可以链接字符串

#函数  
##[input](#input)  
##[print](#print)  
##[while](#while)  
##[for-in](#for-in)
##[append](#append)
##[pop](#pop)
##[extend](#extend)
##[index](#index)
##[insert](#insert)
##[remove](#remove)
##[clear](#clear)
##[del](#del)
##[切片添加](#切片添加)
##[sort](#sort)
##[sorted](#sorted)
##[zip](#zip)


#print  
* 可以将想展示的内容在idee或标准的控制台上显示  
* print()输出的内容可以是数字  
* print()输出的内容可以是字符串  
* print()输出的内容可以是含运算符的表达式  
* print()可以将内容输出到 显示器 文件  
* print()的输出形式有 换行和不换行  
```python
name = 'chen'	

print(name)
print('标识'，id(name))（内存地址）
print('类型',type(name))
print('值'，name)
```

#input
s = intput(str)  

可以用一个字符串s来接收input  
str 会打印在控制台  
之后需要在控制台输入一个字符串付给s

eg:
```python
	present = input('what do you would\n')
	print(present, type(present))
```
输出--> what do you would
appke <class 'str'>


#while
while 判断语句:  
	执行语句   

（和c的很像）  


#index()  
lis = [3,4,5,6,3]（列表）  
print(lis.index(3))  
如果列表中有相同元素，只返回相同元素的第一个在列表中的索引号  
print(lis.index(3,1,3))  
第一个是要查找的元素   
第二个是开始查找的位置   
第三个是查找结束的位置不包括  



#for-in
+ 表达式从（字符串，序列等）中依次取值，即遍历
+ for-in 遍历的对象必须是可迭代对象
+ 结构
	+ for 自定义的变量  in  可迭代对象：
		循环体
+ 循环体内不需要访问自定义变量，可以用下划线代替
+ 可迭代对象
    + 字符串
    + 列表
    + 元组
    + 字典
    + 集合




#append  
在列表末尾添加一个元素  
用法 ---- lis.append(要添加的元素)  
也可以lis.append(lis2)  
+ 就是在lis 的末尾添加一个列表lis2，变成一个嵌套列表  
比如  [34,4,5,5,[3,34,6]]   
+ 使用 append() 函数添加列表时，是添加列表的「引用地址」而不是添加列表内容，当被添加的列表发生变化时，添加后的列表也会同步发生变化。
eg
```python
list1 = ['zhangsan']
a = [1,2,3]
list1.append(a)  # 列表list1添加列表a
print(list1)
a.append(4)  # 列表a发生变化
list1.append(a)。
print(list1)  # 列表list1也会同步变化
```

输出  
```  
['zhangsan', [1, 2, 3]]
['zhangsan', [1, 2, 3, 4], [1, 2, 3, 4]]
```



#extend  
+ 用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
+ 对于extend用法  
	llis.extend  
+ 可以一次性添加多个元素
+ lst.extend(lis2)上面的式子就会变成这样  
[34,4,5,5,3,34,6]


#insert 
lis.insert('要添加的位置','元素')





#remove  

lis.remove('要移除的元素')  
如果有重复元素只删除其中一个  
元素不存在时抛出ValueError  


#pop
+ 删除一个指定索引位置上的元素  
+ 如果不存在抛出IndexError  
+ 不指定索引，删除列表的最后一个  
lis.pop('索引')  




#clear  
清空列表  
lis.clear


#del
删除列表
del lis.


#切片添加  
```python
lis = [1, 2, 3, 4, 5, 6]
lis2 = ['a', 'b', 'c', 'd', 'e']
lis[1:3] = lis2

```
输出 ---- [1, 'a', 'b', 'c', 'd', 'e', 4, 5, 6]
如果3变成2
则是 ---- [1, 'a', 'b', 'c', 'd', 'e',3, 4, 5, 6]



#切片
+ 对序列型对象(如list, string, tuple)的一种高级索引方法。 普通索引只取出序列中 一个下标 对应的元素，而切片取出序列中 一个范围 对应的元素，这里的范围不是狭义上的连续片段。通俗一点就是在一定范围里面.用刀切出一部分,达到自己需要的一部分.  

+ lisp[1,3] =[]   
这个就是把序号为1，2的位置换成空
与切片添加相同



#sort

升序排序  
lis.sort()  

降序排序  
lis.sort(reverse=Ture)  

倒叙  
lis.reverse  


#sorted  
new_list=sorted(lis)
它会产生一个新的列表，而原列表不改变  
sorted（lis，reverse = Ture)  
降序  


#zip()  
用于将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表  

回到[开头](#python)

#语句  
##[if](#if)  
##[pass](#pass)  
##[range()](#range())  
##[break](#break)









#if  
判断语句  
```python  
	money = 1000
	s = int(input('请输入取款金额：')
	if money >= s:
		money -= s
		print('剩下；', money)
	else:
		print('余额不足\n')
	
	(可以用)   
	elif 语句:
		执行语句

```
if也可以这样  
语句1     if  判断语句  else      语句2  
true                                            false  



#range()  
+ 用于生成一个整数序列  
+ 创建range对象的三种方法  
	+ range(stop)   ----   创建一个[ 0 , stop )之间的整数序列，步长为1  
	+ range( start , stop ) ----   创建一个[ start , stop )之间的整数序列，步长为1  
	+ range( start , stop , step)  ----    创建一个[ start ， stop )之间的整数序列，步长为step  
+ 返回值是一个迭代器对象  
+ range类型的优点：不管range对象表示的整数序列有多长，所有range对象占用的内存空间都是相同的，因为仅仅需要存储start，stop，step，只有当用到range对时，才会计算序列中的相关元素 
+ in 与 not in 判断整数序列中是否存在（不存在）指定的整数



#pass  
什么都不做， 只是占用一个占位符，可以跳过  
eg：
```
	if  i < 3 :
		pass
```



#break  
__退出for 或者 while 循环__  
一般与if配合  


#continue  
__用于结束当前循环，进入下一次循环__  




#else
可用于    for    while    if
循环正常结束，没有遇到break则执行else

```python
for item in range(3):
	pwd = input("请输入密码：\n")
	if pwd == '8888':
		print('密码正确！\n')
		break
	else:
		print('密码错误\n')
else:
	print('对不起，三次密码均输入错误\n')
```


#end=''  
表示不换行输出  

·```print('a',end='*')```
''里面是可以打印内容的  
输出：a*  


#列表  
+ s        =   ['hello',' world',98]  
变量名         内容  
(list)  
+ 列表创建  
变量名 = [元素]  
	+ 变量名=list([元素])  
+ 注意 ：元素的类型可以不相同
+ 特点
	+ 列表按元素顺序有序排序
	+ 索引映射唯一一个数据
	+ 列表可以储存重复数据
	+ 任意数据类型混存
	+ 根据需要动态分配和回收内存
+ s[0] 和s[-3] = 都是'hello
它有两种索引，从开始是第0，然后向后递加（正向索引）  
而从最后则是-1，向前递减（逆向索引）


##列表生成式
new_list = [b for i range(start,stop,step)]
	+ b表示列表元素的表达式
	+ i是自定义变量
	+ range是可迭代对象

##切片  
+ 获取列表中的多个元素
	+ 格式 列表名[start : stop : step]

+ 切片的结果 -----  原列表的拷贝
+ 范围      ------ [start , stop)
+ step 默认是1
+ step 为整数 	
	+ [: stop : step] ---- 切片的第一个元素默认是列表的第一个元素
	+ [start, :: step] ---- 切片的最后一个元素默认是列表的最后一个元素
+ step 为负数
	+ [: stop : step] ---- 切片的第一个元素默认是列表的最后一个元素
	+ [start, :: step] ---- 切片的最后一个元素默认是列表的第一个元素





#字典  
+ 字典的特点
	+ 字典的特点  
	+ 字典的创建
		+ scores =  {'张三': 100, '李四' : 38}
		+ 使用内置函数dict()
			dict( name = 'jack' , age = 20)
	+ 字典中的所有元素都是一个 key - value对，key不允许重复，value可以
	+ 字典中的元素是无序的
	+ 字典中的key必须是不可变对象
	+ 字典恶也可以根据需要动态的伸缩
	+ 字典会浪费大量的空间，是一种使用空间换时间的数据结构

+ 获取字典中的元素
	+ scores['键']   ----   返回 键的值  （如果该键不存在，则会报错）
		+ scores['张三']        -------    打印    是   100
	+ scores.get('键')    -----   返回 键的值  （如果该键不存在，则会返回None，如果是，scores.get('键'，数)，则返回这个数）

+ key（键）的判断
	+ '键' in scores  存在测返回True  （not in  则相反）  

+ 删除指定字典元素
	del scores['键']
	
+ 清空字典元素  
	scores.clear()

+ 字典元素的增加
	字典名['要增加的键']=值  
	scores['陈六'] = 90

+ 字典元素的修改	
	字典名['要修改的键']=修改的值
	scores['陈六'] = 100

+ 获取所有的key（键）
	k = scores.keys()
	
+ 获取字典中的valued
	+ v = scores.values()
	+ 直接打印是 dict_values([100,200,33])
	
+ 获取所有的key-value（键值对）
	+ it = scores..items(
	+ 直接打印是 dict_items([( , ), ( , ) ( , )])

+ 注意：这些都可以进行类型转换
	+ eg: print(list(v))   -------     [100,200,33]

+ 字典元素的遍历
```python
for it in  scores:
	print(it, scores[it], scores.get(it)
```
打印   --------  张三 100 100
    	  李四 200 38



+ 字典生成式

    



















